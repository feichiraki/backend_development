## C#程序结构解析

#### 1、学习目标

* C#程序概述
  * 概述/Main方法/顶级语句
* 了解什么是命名空间
* 扩展知识：
  * .net 6前 Program.cs 和 .net 6 Program的区别
* 命名空间

> 注意：我们之所以不直接学习新版本的.NET，而是要对比旧版本进行学习，是为了将版本更替之间的区别展示出来。旧版本更替到的新版本给开发者带来了哪些便利，哪些更替简化了代码的结构，让开发者的代码可读性更佳！

> 参考语言版本：[解决与语言版本和功能相关的错误 - C# | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-messages/feature-version-errors)







#### 2、C#程序的概述

##### 2.1 C#程序的通用结构

C#程序是由一个或多个文件组成。每个文件均包含着0个或多个命名空间(namespace)。一个命名空间包含以下结构：

* 类/结构/接口/枚举/委托等类型。
* 其他命名空间(嵌套于命名空间的命名空间)。

示例代码：

```c#
// A skeleton of a C# program(导入一个C#程序的基本框架)
using System;

// Your program starts here：
Console.WriteLine("Hello world!");

namespace YourNamespace{
    class YourClass{ ... }
    
    struct YourStruct{ ... }
    
    interface IYourInterface { ... }
    
    delegate int YourDelegate();
    
    enum YourEnum{ ... }
    
    // 嵌套的命名空间
    namespace YourNestedNamespace{
         struct YourStruct{ ... }
    }
}
```

前面的示例使用`顶级语句`作为程序的入口点。C#9中添加了此功能。在C#9之前，入口点是名为`Main`的静态方法。

> 在C#9之前，我们把名为Main的静态方法称为主函数，也就是程序的入口。



如果我们要以C#9之前的写法，如下代码所示：

```c#
// A skeleton of a C# program
using System;
namespace YourNamespace
{
    class YourClass
    {
    }

    struct YourStruct
    {
    }

    interface IYourInterface
    {
    }

    delegate int YourDelegate();

    enum YourEnum
    {
    }

    namespace YourNestedNamespace
    {
        struct YourStruct
        {
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            //Your program starts here...
            Console.WriteLine("Hello world!");
        }
    }
}
```





##### 2.2 Main方法

`Main` 方法是 C# 应用程序的入口点。 （库和服务不要求使用 `Main` 方法作为入口点）。`Main` 方法是应用程序启动后调用的第一个方法。

C#程序中只有一个入口点。如果多个类包含`Main`方法，必须使用 StartupObject 编译器选项来编译程序，以指定将哪个 `Main` 方法用作入口点。

> 参考 [StartupObject（C# 编译器选项）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/advanced#mainentrypoint-or-startupobject)。

```C#
class TestClass
{
    static void Main(string[] args)
    {
        // Display the number of command line arguments.
        Console.WriteLine(args.Length);
    }
}
```

自C#9起，我们可以省略编写`Main`这个步骤(显示编写Main方法)，直接编写C#语句(像在`Main`方法中一样编写C#语句)，如下所示：

```C#
Console.WriteLine("Hello world!");
```

如果要了解怎样使用隐式入口点方法编写应用程序代码，参考即将学习的`顶级语句`。



**Main概述**：

* `Main` 方法是可执行程序的入口点，也是程序控制开始和结束的位置。

* `Main` 在类或结构中声明。 `Main` 必须是 [`static`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/static)，它不需要是 [`public`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/public)。 （在前面的示例中，它获得的是[`private`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/private)成员的默认访问权限）。封闭类或结构不一定要是静态的。

  > `Main`可以在类或结构体中声明。(类和结构体在后续的学习中会出现，可以在这里打个记号)
  >
  > * 在结构体中声明我们相信各位会不太理解。在C语言里面不可以声名函数，因为[结构体](https://so.csdn.net/so/search?q=结构体&spm=1001.2101.3001.7020)就是一块连续的内存。但是在C语言中可以声明函数指针，通过函数指针去指向一个函数。
  > * 然而在c++中，我们是可以在[struct](https://so.csdn.net/so/search?q=struct&spm=1001.2101.3001.7020)里面定义函数的。
  > * C#源于C语言系列(C/C++)，当然也是可以在struct中定义函数的。因此，这里所说的struct声明`Main`也是可行的。
  >
  > `Main`方法必须是`static`，这样可以方便调用。

* `Main` 的返回类型可以是 `void`、`int`、`Task` 或 `Task<int>`。

* ......

> 参考文档：[Main() - C# | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/program-structure/main-command-line)





##### 2.3 顶级语句

###### 2.3.1 顶级语句—不使用`Main`方法的程序

从 C# 9(.net 5) 开始，无需在控制台应用程序项目中显式包含 `Main` 方法。 相反，可以使用顶级语句功能最大程度地减少必须编写的代码。 在这种情况下，编译器将为应用程序生成类和 `Main` 方法入口点。　　

> 顶级语句省略了Main方法编写，在运行程序时，编译器将为应用程序生成类和 `Main` 方法入口点。在这里，我们可以理解顶级语句并不是省去了Main方法，而是在运行的程序前给我们添加`Main`方法。
>
> 由此可见，顶级语句会隐式添加Main方法，是一种简化代码的语法，对于开发人员比较友好。

下面是 `Program.cs` 文件中的一段代码，他是 `C#10`(.net 6) 中的一个完整的C#程序：

```C#
Console.WriteLine("Hello World!");
```

上述的代码被称为C#中的`顶级语句`。借助顶级语句，可以为小实用程序（如 Azure Functions 和 GitHub Actions）编写简单的程序。 它们还使初次接触 C# 的程序员能够更轻松地开始学习和编写代码。

> 简而言之，通过顶级语句，可以学习C#比较轻松。不需要了解方法、字段等概念，直接编写具有实现某个功能的代码即可。



###### 2.3.2 顶级语句需要注意的规则

**(1) 仅能有一个顶级文件**

一个应用程序只能有一个入口点。 一个项目只能有一个包含顶级语句的文件。

> 因为我们会给包含顶级语句的文件隐式加入Main方法，将其设置为程序的入口。

如果在项目中的多个文件中放置顶级语句会导致以下编译器错误：

> CS8802：只有一个编译单元可具有顶级语句。

一个项目可具有任意数量的其他源代码文件，这些文件不包含顶级语句。



**(2) 没有其他入口点**

可以显式编写 `Main` 方法，但它不能作为入口点。 编译器将发出以下警告：

> CS7022：程序的入口点是全局代码；忽略“Main()”入口点。

如果我们要显示地编写`Main`方法，必须保证程序的所有文件中不包含顶级语句。

还需要注意的是：在具有顶级语句的项目中，不能使用 [-main](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/advanced#mainentrypoint-or-startupobject) 编译器选项来选择入口点，即使该项目具有一个或多个 `Main` 方法。

> 有顶级语句的情况下，我们是默认把它当作程序的入口点。建议不要在有顶级语句的情况下，再显示编写`Main`或者指定其他类文件(`.cs`)为程序入口。



**(3) using指令**

顶级文件中如果使用using，那么using必须在顶级文件的最开头：

```C#
using System.Text;

StringBuilder builder = new ();
builder.AppendLine("Hello");
builder.AppendLine("World!");

Console.WriteLine(builder.ToString());
```

我们必须要把所有包含using指令的语句放在文件内容的最上面，否则会报错。



**(4) 全局命名空间**

顶级语句隐式位于全局命名空间中。

> 顶级语句中需要导入的命名空间被另外单独拎出放在一个文件中，该文件中存放的都是全局命名空间。
>
> 全局命名空间位于：`项目目录>obj>Debug>net6.0>Net6.GlobalUsings.g.cs`。
>
> 当然，全局命名空间的作用不止于此，在后面会进行讲解。



**(5) 命名空间和类型定义**

具有顶级语句的文件还可以包含命名空间和类型定义，但它们必须位于顶级语句之后。 例如：

```C#
// 以下所有的代码出自C#官网文档
MyClass.TestMethod();
MyNamespace.MyClass.MyMethod();

public class MyClass
{
    public static void TestMethod()
    {
        Console.WriteLine("Hello World!");
    }

}

namespace MyNamespace
{
    class MyClass
    {
        public static void MyMethod()
        {
            Console.WriteLine("Hello World from MyNamespace.MyClass.MyMethod!");
        }
    }
}
```



**(6) ...**

> 更多的规则，请参考官网文档：[顶级语句 - C# | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/program-structure/top-level-statements)







#### 3、Program.cs文件前后对比

在前面的学习中，我们知道了C#程序中的`顶级语句`。而这节有关`Program.cs`文件前后版本对比(.net 5 vs .net 6)的两个主要不同点就是—**顶级语句**。

.net 5生成的Program.cs文件：

```c#
// 导入命名空间
using System;

// 命名空间
namespace Netcore
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

.net 6生成的Program.cs文件：

```C#
Console.WriteLine("Hello, World!");
```

从代码结构上对比：

* .net 6的Program少了 导入的命名空间， 命名空间，少了类，同样也少了Main方法。

从代码多少对比：

* .net 5 生成的代码有多层结构，对于刚接触C#的人不太友好。
* .net 6无疑是简洁明了，只有一行打印输出的代码。

> 从生成的 Program.cs 两版本的对比，新版本.net 6就已经出现了 “少即是多” 的概念。顶级语句在C#中的出现就是一个前兆，底层的框架已经给我们搭好，开发者只需要做的事情就是给他添加功能。







#### 4、命名空间

##### 4.1 概述

命名空间提供了一种用于组织 C# 程序和库的分层方法。 命名空间包含类型和其他命名空间。例如，“Hello, World”程序始于引用 `System` 命名空间的 `using` 指令。代码如下：

```c#
// 导入命名空间
using System;

// 命名空间
namespace Netcore
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

上述程序运行以后的输出是由`System` 命名空间中 `Console` 类的 `WriteLine` 方法生成。 此类由标准类库提供。默认情况下，编译器会自动引用标准类库。

> 什么是标准类库/命名空间？在C#中，我们可以把一个命名空间当作一个类库。在这里我们做一个比喻，可以让我们更好地理解该词含义：
>
> * 命名空间 = 书/根目录/子目录
> * 类 =  书=子目录/每章内容
>
> 一本书中有多个章节，每个章节对应着不同的内容。再往上我们又可以如此定义：
>
> * 命名空间 = 书的类别
> * 类 = 每一本特定类别的书
>
> 颠覆了我们想象的25部国产科幻小说：《带上她的眼睛》、《天年》....
>
> 命名空间通过这样的方式，来组织分层，让我们的程序显得层次有序。





##### 4.2 创建自定义命名空间

除了C#内置的标准库之外，我们开发者还可以自定义命名空间(库)，来编写我们自己的C#程序。下面我们将自己创建一个命名空间。

语法：`namespace 命名空间程序{ }`

示例：

```C#
// 创建一个自定义命名空间 —MyNameSpace
namespace MyNameSpace{
    // 编写于命名空间内部的代码
}
```





##### 4.3 using 导入命名空间

当我们要使用一个命名空间中的功能时，我们需要引入该命名空间。C#提供了`using`关键字，通过`using`引入命名空间后，我们就在当前文件使用到里面的功能或访问到里面的内容。

语法：`using 命名空间名称`

示例：

```c#
// 例如之前Hello World程序的引入
using System;	
// 引入我们创建的命名空间
using MyNameSpace;
```

> 注意：在C#中，每一条语句的是以英文分号`;`结尾。





